"""Luminosity function file reader."""

import re
import numpy as np
from pathlib import Path
from typing import Dict, TextIO


class LuminosityFunction:
    """Reader for luminosity function (LF) data files from GALFORM.
    
    This class parses .lf files generated by the `sample_gals` program,
    including metadata from headers and the main data table.
    
    Attributes:
        filepath: Path to the input LF file
        num_bins: Number of luminosity bins (NLBIN)
        num_bands: Number of filter bands (NBAND)
        bands: Information about each band
        data: Luminosity function data by band
    """

    def __init__(self, filepath: str):
        """Initialize the LuminosityFunction by reading and parsing a file.
        
        Args:
            filepath: Path to the luminosity function data file
            
        Raises:
            FileNotFoundError: If the specified file does not exist
            ValueError: If the file content has unexpected format
        """
        self.filepath = Path(filepath)
        if not self.filepath.is_file():
            raise FileNotFoundError(f"File not found: {self.filepath}")
        
        self._parse_file()
    
    def _parse_file(self) -> None:
        """Parse the LF file contents."""
        with open(self.filepath, 'r') as f:
            self._parse_header(f)
            self._parse_data_table(f)
    
    def _parse_header(self, f: TextIO) -> None:
        """Parse header information from the file."""
        # Read first line to get NLBIN and NBAND
        first_line = f.readline().strip()
        match = re.match(r'^\s*(\d+)\s+(\d+)', first_line)
        if not match:
            raise ValueError("Could not parse NLBIN and NBAND from first line")
        
        self.num_bins = int(match.group(1))
        self.num_bands = int(match.group(2))
        
        # Read band information
        self.bands = {}
        for _ in range(self.num_bands):
            band_line = f.readline().strip()
            parts = band_line.split()
            if len(parts) >= 2:
                band_num = int(parts[0])
                band_name = parts[1]
                self.bands[band_name] = {'number': band_num}
    
    def _parse_data_table(self, f: TextIO) -> None:
        """Parse the main data table."""
        self.data = {}
        
        # Initialize arrays for each band
        for band_name in self.bands.keys():
            self.data[band_name] = {
                'mag': np.zeros(self.num_bins),
                'phi': np.zeros(self.num_bins),
                'phi_error': np.zeros(self.num_bins)
            }
        
        # Read data rows
        for i in range(self.num_bins):
            line = f.readline().strip()
            if not line:
                continue
            
            values = list(map(float, line.split()))
            if len(values) < 1 + 2 * self.num_bands:
                continue
            
            mag = values[0]
            for j, band_name in enumerate(self.bands.keys()):
                phi_idx = 1 + 2 * j
                err_idx = phi_idx + 1
                
                self.data[band_name]['mag'][i] = mag
                if phi_idx < len(values):
                    self.data[band_name]['phi'][i] = values[phi_idx]
                if err_idx < len(values):
                    self.data[band_name]['phi_error'][i] = values[err_idx]
    
    def get_band_data(self, band_name: str) -> Dict[str, np.ndarray]:
        """Get data for a specific band.
        
        Args:
            band_name: Name of the band
            
        Returns:
            Dictionary with 'mag', 'phi', 'phi_error' arrays
        """
        if band_name not in self.data:
            raise KeyError(f"Band '{band_name}' not found in data")
        return self.data[band_name]
    
    def __repr__(self) -> str:
        return f"LuminosityFunction('{self.filepath.name}', bins={self.num_bins}, bands={list(self.bands.keys())})"
